<?php

/**
 * Implements hook_menu().
 */
function millennium_cck_menu() {
  $items = array();
  $items[MILLENNIUM_SETTINGS_PATH . '/fieldmap'] = array(
    'title' => 'Field mapping',
    'description' => 'Configure MARC import mapping settings.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('millennium_cck_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer millennium'),
  );
  return $items;
}

/**
 * Callback for drupal_get_form for cck mapping settings form.
 */
function millennium_cck_settings_form($form, &$form_state) {
  global $_millennium_field_labels;
  $form = array();

  // Get destination content type
  $millennium_node_type = variable_get('millennium_marc_node_type', 'page');
  $content_type_fields = field_info_instances('node', $millennium_node_type);

  // Help text
  $form['help'] = array(
    '#type' => 'markup',
    '#markup' => t(
      '<p>Select what data to import into each of the fields available for the !type-link content type. <strong>Note: only text fields are currently supported.</strong></p>',
      array('!type-link' => l($millennium_node_type, 'admin/structure/types/manage/' . str_replace("_", "-", $millennium_node_type) . '/fields'))
    ),
  );
  // Build mapping destination field options
  $options = array(
    -1 => t('<Set field to empty value>'),
  );
  foreach ($_millennium_field_labels as $biblio_name => $biblio_label) {
    $options[$biblio_name] = $biblio_label;
  }

  // Build form
  foreach ($content_type_fields as $fieldname => $field) {
    if ($field['widget']['module'] == 'text' || $field['widget']['module'] == 'number') {
      $form["millennium_cck_mapping_{$fieldname}"] = array(
        '#type' => 'select',
        '#title' => check_plain($field['label']),
        '#options' => $options,
        '#default_value' => variable_get("millennium_cck_mapping_{$fieldname}", -1),
      );
    }
  }
  return system_settings_form($form);
}

/**
 * Implements hook_millennium_nodeobject_alter().
 */
function millennium_cck_millennium_nodeobject_alter(&$nodeobject, $marc) {
  // Handle CCK mappings
  millennium_cck_biblio_to_node($nodeobject, $nodeobject->millennium_biblio_data);
}

/**
 * Map biblio data into CCK fields according to configuration
 */
function millennium_cck_biblio_to_node(&$node, $biblio_values) {
  static $content_type_fields, $language, $translate;

  // Do some one-time initialization
  if (!isset($content_type_fields)) {
    // Get destination content type
    $millennium_node_type = variable_get('millennium_marc_node_type', 'page');
    $content_type_fields = field_info_instances('node', $millennium_node_type);

    // Pick the language to use when mapping item language and item type
    $language = variable_get('millennium_taxonomy_language', 'english');
    if ($language == 'site_default') {
      $translate = TRUE;
      $language = language_default('language');
    }
    else {
      $translate = FALSE;
      $language = 'en';
    }
  }

  foreach ($content_type_fields as $dest_fieldname => $field) {
    // Get mapping. Skip if none assigned
    $biblio_fieldname = variable_get("millennium_cck_mapping_{$dest_fieldname}", -1);
    if ($biblio_fieldname == -1) {
      // Leave untouched
      continue;
    }

    if (empty($node->$dest_fieldname)) {
      $node->{$dest_fieldname} = array();
    }
    // Clear existing values
    foreach ($node->$dest_fieldname as $index => $dummy) {
      $node->{$dest_fieldname}[$node->language][$index]['value'] = '';
    }

    if ($biblio_fieldname == -1) {
      // Just clear out the values (which we did already)
      continue;
    }

    // Get max num. of values this field can hold. TODO
    #$num_allowed_values = $content_type_fields[$dest_fieldname]["multiple"];
    #if ($num_allowed_values == 0) {
    #  $num_allowed_values = 1;
    #}
    $num_allowed_values = 99; // TODO

    // Get value to write to CCK field value
    if (isset($biblio_values[$biblio_fieldname])) {
      // Convert some fields to their human-readable equivalent
      if ($biblio_fieldname == "type" || $biblio_fieldname == "lang") {
        $value = _millennium_human_string($biblio_values, $biblio_fieldname, $translate, $language);
      }
      else {
        // Non-translateable values.
        $value = $biblio_values[$biblio_fieldname];
      }
      if (!$value) {
        continue;
      }

      if (is_array($value)) {
        // Handle multi-valued (array) biblio data values
        // map into multiple CCK values up to that field's # of values limit
        if (!is_array($node->{$dest_fieldname})) {
          $node->{$dest_fieldname} = array($node->language => array());
        }
        foreach ($value as $index => $val) {
          if (trim($val) == '') {
            continue;
          }
          if (!isset($node->{$dest_fieldname}[$node->language][$index])) {
            $node->{$dest_fieldname}[$node->language][$index] = array();
          }
          $node->{$dest_fieldname}[$node->language][$index]['value'] = $val;
        }
      }
      else {
        // Handle single-valued (string) biblio data value
        // Set CCK field's first value
        $node->{$dest_fieldname}[$node->language][0]['value'] = $value;
      }
    }
    else {
      // TODO: Decide what to do when incoming value is empty. E.g. Clear existing data or leave untouched?
      // Empty incoming value: reset the value.
      $node->{$dest_fieldname}[$node->language][0]['value'] = '';
    }
  }
}
